---
title: "An introduction to weakly associated vectors sampling"
author: "Raphaël Jauslin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(wave)

```


## Introduction
Geographical data are generally autocorrelated. This is why it is preferable to avoid the measurement of neighboring units. We propose a new method for selecting spread samples from a finite spatial population with equal or unequal inclusion probabilities. The propsed method is called `wave` and stands for Weakly Associated VEctors. it is based on the definition of the contiguity structure by using a very dense stratification. The method satisfies exactly the inclusion probabilities and provides samples that are very well spread. This document propose an introduction to understand how to use the function `wave()`.


## Data generation

We use the data set `meuse` from the package `sp`, describe by the following statement. *This data set gives locations and topsoil heavy metal concentrations, along with a number of soil and landscape variables at the observation locations, collected in a flood plain of the river Meuse, near the village of Stein (NL)*. As it is explained by @grafstrom:tille:2013, we proposed to generate the inclusion probabilities proportional to the copper concentration, a variable that have a strong spatial correlation.

```{r}
# install.packages(sp)
library(sp)
library(sampling)
data("meuse")
data("meuse.riv")
meuse.riv <- meuse.riv[which(meuse.riv[,2] < 335000 & meuse.riv[,2] > 328750),]

X <- scale(as.matrix(meuse[,1:2]))
pik <- inclusionprobabilities(meuse$copper,30)
```

## Sample selection

The sample selection is easily performed by the function `wave()`.

```{r}
s <- wave(X,pik)
sum(s)
```



```{r,fig.width=5,fig.height=5}
library(ggplot2)
p <- ggplot()+
  geom_polygon(data = data.frame(x = meuse.riv[,1],y = meuse.riv[,2]),
               aes(x = x,y = y),
               fill = "lightskyblue2",
               colour= "grey50")+
  geom_point(data = meuse,
             aes(x = x,y = y,size = copper),
             shape = 1,
             stroke = 0.3)+
  geom_point(data = meuse[which(s == 1),],
             aes(x = x,y = y,size = copper),
             shape = 16)+
  labs(x = NULL,
       y = NULL,
       title = "Meuse river",
       size = "Copper",
       caption = NULL)+
  scale_size(range = c(0.5, 2))+
  coord_equal()+
  theme_minimal()+
  theme(axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank())
p
  
```



## Spatial balance

### Voronoï polygons
One way of measuring the spread of a sample was developped by @stevens:olsen:2004 and then suggested by @grafstrom:lundstrom:2012. It is based on the Voronoï polygons and is given by,

$$ B(\bf s) = \frac{1}{n}\sum_{i \in s} (v_i - 1)^2 $$
where $v_i$ is equal to the sum of the inclusion probabilities inside the $i$th polygons and $\bf s$ is the vector of size $N$ with elements equal 0 or 1. This quantity is implemented in the package `BalancedSampling` with the function `sb()`.

The most $B(\bf s)$ is close to zero, the better is the spatial balance of the sample. Graphically, we obtain the following plot.

```{r,include=FALSE}
library(Rcpp)
Rcpp::cppFunction('
		NumericVector sbAll(NumericVector p, NumericMatrix x, NumericVector s){
		int N = x.nrow();
		int ncol = x.ncol();
		int n = s.size();
		NumericVector incl(N);
		NumericVector nearest(n);
		int nrNearest = 0;
		double mindist, d;
		for(int i=0;i<N;i++){incl[i]=0.0;}
		for(int i=0;i<N;i++){
		nrNearest = 0;
		mindist = 1e+200;
		for(int j=0;j<n;j++){
		d = 0.0;
		for(int k=0;k<ncol;k++){
		d += pow(x(i,k)-x(s[j]-1,k),2); // distance i to the jth element
		}
		if(d==mindist){
		nearest[nrNearest]=s[j];
		nrNearest++;
		}
		if(d<mindist){
		mindist = d;
		nearest[0] = s[j];
		nrNearest = 1;
		}
		}
		// std::cout << incl << std::endl;
		for(int k=0;k<nrNearest;k++){
		// std::cout << nrNearest << std::endl;
		// std::cout << p[i]/nrNearest << std::endl;
		incl[nearest[k]-1] = incl[nearest[k]-1] + p[i]/nrNearest;
		}
		}
		return incl;
		// for(int i=0;i<n;i++){
		//   res += pow(incl[s[i]-1]-1,2);
		// }
		// return res/n;
		}')

```



```{r,fig.width=7,fig.height=5}

library(sp)
library(sampling)
library(ggvoronoi)
data("meuse")
data("meuse.area")

v <- sbAll(pik,as.matrix(meuse[,1:2]),s = which(s == 1))
meuse$v <- v

p <- p + geom_voronoi(data = meuse[which(s == 1),],
               aes(x = x,y = y,fill = v),
               outline =as.data.frame(meuse.area),
               size = 0.1,
               colour = "black")+
  geom_point(data = meuse,
             aes(x = x,y = y,size = copper),
             shape = 1,
             stroke = 0.3)+
  geom_point(data = meuse[which(s == 1),],
             aes(x = x,y = y,size = copper),
             shape = 16)+
  # scale_fill_viridis_c()
  scale_fill_gradient2(low = "firebrick4", mid = "white",
  high = "midnightblue", midpoint = 1, space = "Lab",
  na.value = "grey50", guide = "colourbar", aesthetics = "fill")
p

```



### Moran index

Another way to estimate the spatial spread is developped by @tille:dickson:2018, it uses a corrected version of the traditional Moran's $I$ index. This estimator use spatial weights $w_{ij}$ that indicates how a unit $i$ is close from the unit $j$. Such matrix is supposed to include inclusion probabilities in its computation, hence, the spatial weights matrix $\bf W$ is generally not symmetric. The spatial balance measure is given by

$$ I_B =\frac{(\bf s-\bf \bar{s}_w)^\top \bf W (\bf s-\bf \bar{s}_w)}{\sqrt{(\bf s-\bf \bar{s}_w)^\top \bf D (\bf s-\bf \bar{s}_w) (\bf s-\bf \bar{s}_w)^\top \bf B (\bf s-\bf \bar{s}_w) }}, $$
where $\bf D$ is the diagonal matrix containing the $w_i$, 
$$\bf \bar{s}_w = \bf 1 \frac{\bf s^\top \bf W \bf 1}{\bf 1^\top \bf W \bf 1},$$
and 
$$\bf B = \bf W^\top \bf D^{-1} \bf W - \frac{\bf W^\top \bf 1\bf 1^\top \bf W}{\bf1^\top \bf W \bf 1}.$$

The Moran's $I$ index is implemented in the function `IB()`. It is possible to specifiy your own spatial weights with the argument `W`. There is no natural way of defining $\bf W$, here we propose to consider for each unit only the neighbour such that the sum of the inclusion probabilities of the stratum sum up to 1. It is implemented in the function `wpik()`. Another way of estimating the spatial weights is developped by @tille:dickson:2018 and use the inverse of the inclusion probabilities $1/\pi_i$ to estimate the neighbours of the unit $i$. It is implemented in the function `wpik2()`.

```{r}

W <- wpik(X,pik)
image(W)

W <- W - diag(diag(W))
IB(W,s)

```


## Performance



```{r, echo=FALSE}
library(BalancedSampling)
library(kableExtra)
n1 <- 10
n2 <- 20
n3 <- 40
n <- c(n1,n2,n3)
N_meuse <- nrow(meuse)


pik_meuse <- list(rep(n1/N_meuse,N_meuse),
               rep(n2/N_meuse,N_meuse),
               rep(n3/N_meuse,N_meuse),
               inclusionprobabilities(meuse$copper,n1),
               inclusionprobabilities(meuse$copper,n2),
               inclusionprobabilities(meuse$copper,n3))


SIM <- 1

s <- q <- W1<- W<- Ib <- Ib1 <- Sb <- rep(list(0),6)
names(s) <- names(q) <- names(W) <-names(W1) <- names(Ib1) <- names(Ib) <- names(Sb) <-c("n1","n2","n3","n1_un","n2_un","n3_un")
for(j in 1:length(s)){
  Ib1[[j]] <- Ib[[j]] <- Sb[[j]] <- data.frame(matrix(rep(0,5*SIM),nrow = SIM,ncol =5))
  colnames(Ib1[[j]]) <- colnames(Ib[[j]]) <- colnames(Sb[[j]]) <-  c("wave","lpm1","scps","srswor","grts")
  s[[j]] <-  rep(list(0),5)
  names(s[[j]]) <- c("wave","lpm1","scps","srswor","grts")
  pikt <- UPMEpiktildefrompik(pik_meuse[[j]])
  w_maxent <- pikt/(1-pikt)
  q[[j]] <- UPMEqfromw(w_maxent,sum(pik_meuse[[j]]))
}



for(tt in 1:SIM){
  for(j in 1:length(s)){
    #W
    W[[j]] <- wpik(X,pik_meuse[[j]])
    W[[j]]  <-  W[[j]] - diag(diag(W[[j]]))
    #W1
    W1[[j]] <- wpik2(X,pik_meuse[[j]],tore = F,jitter = F,toreBound = 0)
    #wave
    s[[j]][[1]] <- as.vector(wave(X,pik_meuse[[j]],bound = 1,tore = F,jitter = F,oneD = F))

    #lpm1
    s[[j]][[2]] <- rep(0,N_meuse)
    s[[j]][[2]][lpm1(pik_meuse[[j]],X)] <- 1

    #scps
    s[[j]][[3]] <- rep(0,N_meuse)
    s[[j]][[3]][scps(pik_meuse[[j]],X)] <- 1

    #srswor
    # s[[i]][[j]][[4]] <- srswor(sum(pik[[i]][[j]]),N[[i]])
    s[[j]][[4]] <- UPMEsfromq(q[[j]])

    #grts
    # s[[j]][[5]] <- GRTS(pik_meuse[[j]],X[,1],X[,2])
    s[[j]][[5]] <- rep(0,N_meuse)
    s[[j]][[5]][lpm2(pik_meuse[[j]],X)] <- 1
    }

  # fill Ib and Sb
  for(j in 1:length(s)){
    for(k in 1:length(s[[j]])){
      Ib1[[j]][tt,k] <- IB(W1[[j]],s[[j]][[k]])
      Ib[[j]][tt,k] <- IB(W[[j]],s[[j]][[k]])
      Sb[[j]][tt,k] <- sb(pik_meuse[[j]],X,which(s[[j]][[k]] == 1))
    }
  }
}




datIbcsv <- datIb1csv <- datSbcsv <- data.frame()

for(j in 1:length(Ib)){
  datIbcsv_tmp <- Ib[[j]]
  datIb1csv_tmp <- Ib1[[j]]
  datSbcsv_tmp <- Sb[[j]]
  datIbcsv_tmp$type <-  rep(paste(names(Ib)[j],sep = ":"),SIM)
  datIb1csv_tmp$type <-  rep(paste(names(Ib1)[j],sep = ":"),SIM)
  datSbcsv_tmp$type <-  rep(paste(names(Sb)[j],sep = ":"),SIM)
  datIbcsv <- rbind(datIbcsv_tmp,datIbcsv)
  datIb1csv <- rbind(datIb1csv_tmp,datIb1csv)
  datSbcsv <- rbind(datSbcsv_tmp,datSbcsv)
}


Ib1 <- lapply(Ib1,colMeans)
Ib <- lapply(Ib,colMeans)
Sb <- lapply(Sb,colMeans)

nom <- c(paste("$n =",n1,"$"),paste("$n =",n2,"$"),paste("$n =",n3,"$"))



Ib1 <- cbind(data.frame(matrix(c(Ib1[[1]],Ib1[[2]],Ib1[[3]]),nrow = 3,byrow = T )),
      data.frame(matrix(c(Ib1[[4]],Ib1[[5]],Ib1[[6]]),nrow = 3,byrow = T )))
Ib1 <- cbind(nom,Ib1)
# Ib1[[i]] <- cbind(rep(names(Ib1)[i],3),Ib1)


Ib<- cbind(data.frame(matrix(c(Ib[[1]],Ib[[2]],Ib[[3]]),nrow = 3,byrow = T )),
      data.frame(matrix(c(Ib[[4]],Ib[[5]],Ib[[6]]),nrow = 3,byrow = T )))
Ib <- cbind(nom,Ib)
# Ib[[i]] <- cbind(rep(names(Ib)[i],3),Ib[[i]])

Sb <- cbind(data.frame(matrix(c(Sb[[1]],Sb[[2]],Sb[[3]]),nrow = 3,byrow = T )),
      data.frame(matrix(c(Sb[[4]],Sb[[5]],Sb[[6]]),nrow = 3,byrow = T )))
Sb <- cbind(nom,Sb)
# Sb[[i]] <- cbind(rep(names(Sb)[i],3),Sb[[i]])

colnames(Ib1) <-colnames(Ib) <- colnames(Sb) <-  c(" ","wave","lpm1","scps","srswor","grts","wave","lpm1","scps","maxent","grts")



datmeuse <- rbind(Ib1,Ib,Sb)

```


```{r,echo = FALSE}

kable(datmeuse, format = "html",digits = 3, booktabs = T, caption = paste0("Results of ",SIM," simulations on the Meuse dataset. The population size is equal to ",N_meuse,"."),row.names = FALSE,escape = FALSE)%>%
 add_header_above(c(" " = 1,"Equal probabilities" = 5, "Unequal probabilities" = 5),escape = F) %>%
 add_header_above(c(" " = 1,"Sampling design" = 10)) %>%
 # add_footnote(c("$\\pi_k = \\pi = n/N$","for all $j\\neq k, \\pi_k \\neq \\pi_j$  and $\\sum_{k \\in U} \\pi_k = n$"),escape = F,notation = "symbol") %>%
 group_rows("$I_{B_1}$",1,3,escape = F,bold = F,latex_gap_space = "1em")%>%
 group_rows("$I_B$",4,6,escape = F,bold = F,latex_gap_space = "1em")%>%
 group_rows("$B$",7,9,escape = F,bold = F,latex_gap_space = "1em") %>%
 kable_styling(latex_options = c("hold_position"))

```


## References
