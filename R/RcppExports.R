# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @encoding UTF-8
#' @title Spatial balance based on Moran's I index
#'
#' @description
#'
#' This function implements the spatial balanced based on Moran's I index.
#'
#' @param W A \code{\link[Matrix]{sparseMatrix}} representing the spatial weights. See \code{\link{wpik}}.
#' @param s A numeric vector of 0 and 1 that represent the sample.
#'
#' @return A numeric value that represent the spatial spreading measure. It could be any real value between -1 (spread) and 1 (clustered). 
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references
#' Tillé, Y., Dickson, M.M., Espa, G., and Guiliani, D. (2018). Measuring the spatial balance of a sample: A new measure based on Moran's I index.
#' \emph{Spatial Statistics}, 23, 182-192. \url{https://doi.org/10.1016/j.spasta.2018.02.001}
#' 
#' @seealso
#' \code{\link{wpik}}
#' 
#' @examples
#' \dontrun{
#'   N <- 100
#'   n <- 20
#'   x <- seq(1,sqrt(N),1)
#'   X <- expand.grid(x,x)
#'   pik <- rep(n/N,N)
#'   W <- wpik(as.matrix(X),pik,bound = 1,tore = TRUE,jitter = FALSE,toreBound = sqrt(N))
#'   W <- W - diag(diag(W))
#'   s <- round(wave(as.matrix(X),pik,tore = TRUE,jitter = TRUE,comment = TRUE))
#'   system.time(I1 <- IB(W,s))
#' 
#'   plot(X)
#'   points(X[s == 1,],pch = 16)
#' }
#' 
#' @export
IB <- function(W, s) {
    .Call(`_wave_IB`, W, s)
}

#' @encoding UTF-8
#' @title Iterative proportional fitting procedure (IPFP) or raking ratio.
#' 
#' @description
#' Iterative proportional fitting procedure (IPFP) implemented for \code{\link[Matrix]{sparseMatrix}}.
#'
#' @param A A \code{\link[Matrix]{sparseMatrix}}.
#' @param bh A vector representing the row margin.
#' @param bi A vector representing the columm margin.
#' @param maxiter An integer indicating the maximum iterations allowed.
#' @param tol A real value that the error should reach before stoped.
#' @param comment an optional logical value, indicating some informations during the execution. Default is FALSE.
#' 
#' @return the sparse matrix A adjusted.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references
#' Tillé, Y. (2019). \emph{Théorie des sondages}. Dunod, 2nd édition
#' 
#' @seealso
#'  \code{\link{IPFPsym}}, \code{\link{wpik}}
#' 
#' @examples
#' \dontrun{
#' X <- as.matrix(cbind(runif(1000),runif(1000)))
#'   pik <- rep(1/5,1000)
#'   A <- wpik(X,pik,bound = 1,tore = FALSE,jitter = FALSE,toreBound = 0.0)
#'   A <- A+t(A)
#'   isSymmetric(A)
#'   
#'   A1 <- IPFP(A,bh = rep(1,nrow(A)),
#'             bi = rep(1,nrow(A)),
#'             maxiter = 1000,
#'             tol = 1e-4,
#'             comment = TRUE)
#'   A2 <- IPFPsym(A,bh = rep(1,nrow(A)),
#'             bi = rep(1,nrow(A)),
#'             maxiter = 4000,
#'             tol = 1e-4,
#'             comment = TRUE) # takes more iterations because the symmetric structure is kept.
#'   rowSums(A1)
#'   rowSums(A2)
#'   colSums(A1)
#'   colSums(A2)
#'   
#'   isSymmetric(A1) # not symmetric
#'   isSymmetric(A2) # symmetric
#' }
#' 
#' @export
IPFP <- function(A, bh, bi, maxiter = 300L, tol = 1e-9, comment = FALSE) {
    .Call(`_wave_IPFP`, A, bh, bi, maxiter, tol, comment)
}

#' @encoding UTF-8
#' @title Iterative proportional fitting procedure (IPFP) or raking ratio for symmetric sparse matrix.
#' 
#' @description
#' Iterative proportional fitting procedure (IPFP) implemented for \code{\link[Matrix]{sparseMatrix}}.
#'
#' @param A A \code{\link[Matrix]{sparseMatrix}}.
#' @param bh A vector representing the row margin.
#' @param bi A vector representing the columm margin.
#' @param maxiter An integer indicating the maximum iterations allowed.
#' @param tol A real value that the error should reach before stoped.
#' @param comment an optional logical value, indicating some informations during the execution. Default is FALSE.
#' 
#' @return the sparse matrix A adjusted.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references
#' Tillé, Y. (2019). \emph{Théorie des sondages}. Dunod, 2nd édition
#' 
#' @seealso
#' \code{\link{IPFP}}, \code{\link{wpik}}
#' 
#' @examples
#' \dontrun{
#'   X <- as.matrix(cbind(runif(1000),runif(1000)))
#'   pik <- rep(1/5,1000)
#'   A <- wpik(X,pik,bound = 1,tore = FALSE,jitter = FALSE,toreBound = 0.0)
#'   A <- A+t(A)
#'   isSymmetric(A)
#'   
#'   A1 <- IPFP(A,bh = rep(1,nrow(A)),
#'             bi = rep(1,nrow(A)),
#'             maxiter = 1000,
#'             tol = 1e-4,
#'             comment = TRUE)
#'   A2 <- IPFPsym(A,bh = rep(1,nrow(A)),
#'             bi = rep(1,nrow(A)),
#'             maxiter = 4000,
#'             tol = 1e-4,
#'             comment = TRUE) # takes more iterations because the symmetric structure is kept.
#'   rowSums(A1)
#'   rowSums(A2)
#'   colSums(A1)
#'   colSums(A2)
#'   
#'   isSymmetric(A1) # not symmetric
#'   isSymmetric(A2) # symmetric
#' }
#' 
#' @export
IPFPsym <- function(A, bh, bi, maxiter = 300L, tol = 1e-9, comment = FALSE) {
    .Call(`_wave_IPFPsym`, A, bh, bi, maxiter, tol, comment)
}

#' @title Euclidean distance with tore option
#'
#' @description
#' Calculate the distance from the unit k to the other units.
#'
#'
#' @param X A matrix of size N x 2, it should represent the 2D position of the units.
#' @param k An integer value, the index of the unit.
#' @param tore logical, if we are considering the distance on a tore. Default is TRUE.
#' @param toreBound A numeric value that specify the size of the grid.
#'
#' @return A vector that represent the distance values.
#'
#'
#' @export
distUnitk <- function(X, k, tore, toreBound) {
    .Call(`_wave_distUnitk`, X, k, tore, toreBound)
}

#' @encoding UTF-8
#' @title Projection operator
#'
#' @description
#'
#' This operator projects the vector v orthogonally onto the line spanned by vector u.
#'
#' @param v vector projected.
#' @param u vector that define the line on which we project.
#' 
#' @details
#' 
#' The projection operator is defined by :
#' 
#' \deqn{proj_u(v) = \frac{\langle u , v \rangle}{\langle u, u \rangle} u}
#'  where \eqn{\langle . , . \rangle} is the inner product also written \eqn{u^\top v}.
#' 
#' @return The projection of the vector v onto the line spanned by the vector u.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references 
#' \url{https://en.wikipedia.org/wiki/Projection_(linear_algebra)}s
#' 
#' 
#' @examples
#' \dontrun{
#' u = c(0,1)
#' v = c(1,1)
#' projOp(v,u)
#' v - projOp(v,u)
#' }
#' 
#' @export
projOp <- function(v, u) {
    .Call(`_wave_projOp`, v, u)
}

#' @title Column sums on sparse matrix.
#'
#' @description
#' Same usage of the function \code{\link[Matrix]{colSums}}.
#'
#' @param x A sparse matrix of class \code{\link[Matrix]{sparseMatrix}}.
#'
#' @details
#' This function is designed to be used for other \code{RcppArmadillo} function inside of the package. Nevertheless it could be used in R.
#' It only loops on the non-zero entries of the sparseMatrix. The function \code{\link[Matrix]{colSums}} should be prefer because is 
#' a little bit faster.
#'
#' @return A numeric vector that represent the sums of the column of x. 
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @seealso
#' \code{\link[Matrix]{colSums}}, \code{\link[Matrix]{rowSums}}.
#' 
#' @examples
#' \dontrun{
#' sp <- rsparsematrix(5000,5000,density = 0.4)
#' system.time(test1 <- Matrix::colSums(sp))
#' system.time(test2 <- colSumsiter(sp))
#' }
#' @export
colSumsiter <- function(x) {
    .Call(`_wave_colSumsiter`, x)
}

#' @title Row sums on sparse matrix.
#'
#' @description
#' Same usage of the function \code{\link[Matrix]{rowSums}}.
#'
#' @param x A sparse matrix of class \code{\link[Matrix]{sparseMatrix}}.
#'
#' @details
#' This function is designed to be used for other \code{RcppArmadillo} function inside of the package. Nevertheless it could be used in R.
#' It only loops on the non-zero entries of the sparseMatrix. The function \code{\link[Matrix]{rowSums}} should be prefer because is 
#' a little bit faster.
#'
#' @return A numeric vector that represent the sums of the rows of x. 
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @seealso
#' \code{\link[Matrix]{colSums}}, \code{\link[Matrix]{rowSums}}.
#' 
#' 
#' @examples
#' \dontrun{
#' sp <- rsparsematrix(5000,5000,density = 0.4)
#' system.time(test1 <- Matrix::colSums(sp))
#' system.time(test2 <- colSumsiter(sp))
#' }
#' 
#' @export
rowSumsiter <- function(x) {
    .Call(`_wave_rowSumsiter`, x)
}

#' @encoding UTF-8
#' @title Weakly associated vectors sampling
#'
#' @description
#'
#' Select spread spatial samples with inclusion probabilities using the weakly associated vectors sampling method.  
#'
#' @param X matrix of size N x 2 representing the spatial position. 
#' @param pik vector of the inclusion probabilites. The length should be equal to N.
#' @param bound A scalar representing the bound to reach before a new strata is considered. See \code{\link{wpik}}. Default is 1.
#' @param tore an optional logical value, if we are considering the distance on a tore. See \code{\link{distUnitk}}. Default is TRUE.
#' @param jitter an optional logical value, if you would use a jitter perturbation. See Details for more infomrations. Default is FALSE.
#' @param oneD an optional logical value, specifying if we are in one dimension. Default is FALSE.
#' @param comment an optional logical value, indicating some informations during the execution. Default is FALSE.
#'
#' @details
#' 
#' A contiguity table \eqn{W} is calculated from the matrix \eqn{X}.
#' \code{wave} sampling estimate a vector \eqn{u} that is
#' the weakest associated vector of the linear transformations generated by \eqn{W}.
#' The vector \eqn{u} is then used to update the inclusion probabilities vector \eqn{\pi_k}.
#' 
#'
#' @return A vector of size N with elements equal 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for non-selected unit.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references 
#' \url{https://en.wikipedia.org/wiki/Singular_value_decomposition}
#' 
#' @seealso
#' \code{\link{wpik}}, \code{\link{distUnitk}}.
#' 
#' 
#' @examples
#' \dontrun{
#'   N <- 36 # 6 x 6 grid
#'   n <- 12 # number of unit selected
#'   x <- seq(1,sqrt(N),1)
#'   X <- as.matrix(cbind(rep(x,times = sqrt(N)),rep(x,each = sqrt(N))))
#'   pik <- rep(n/N,N)
#'   s <- wave(X,pik, tore = TRUE,jitter = FALSE)
#'   plot(X)
#'   points(X[s == 1,],pch = 16)
#' }
#' 
#' 
#' 
#' @export
wave <- function(X, pik, bound = 1.0, tore = FALSE, jitter = FALSE, oneD = FALSE, comment = FALSE) {
    .Call(`_wave_wave`, X, pik, bound, tore, jitter, oneD, comment)
}

#' @encoding UTF-8
#' @title Spatial weights from pik
#'
#' @description
#'
#' Spatial weights calculated from inclusion probabilies taking distance between units into account.
#'  
#'
#' @param X matrix of size N x 2 representing the spatial position. 
#' @param pik vector of the inclusion probabilites. The length should be equal to N.
#' @param bound A scalar representing the bound to reach before a new strata is considered. See \code{\link{wpik}}. Default is 1.
#' @param tore an optional logical value, if we are considering the distance on a tore. See \code{\link{distUnitk}}. Default is TRUE.
#' @param jitter an optional logical value, if you would use a jitter perturbation. See Details for more infomrations. Default is FALSE.
#' @param toreBound A numeric value that specify the size of the grid.
#' 
#' @details
#' 
#' Spatial weights indicates how close the units are frome each others. Hence a large value \eqn{w_{ij}} means that the unit i 
#' is close to the unit j. This function consider that a unit represents its neighbor till their inclusion probabilities
#' sum to 1.
#' 
#' We define \eqn{H_i} the set of the nearest neighbor of the unit i including i such that the sum of their inclusion
#' probabilities is just greater than 1. Moreover, let \eqn{h_i = card{H_i}}, the number of elements in \eqn{H_i}.
#' The matrix \eqn{W} is then defined as follows,
#' 
#' \deqn{ w_{ij} = \pi_j  h_i - 1 nearest neighbor of }
#' 
#'
#' Hence, the ith row of the matrix represents neighborhood or stratum of the unit such that the inclusion probabilities sum up
#' to 1 and the ith column the weights that unit i takes for each stratum. 
#' 
#' 
#' @return A sparse matrix representing the spatial weights.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references 
#' Tillé, Y., Dickson, M.M., Espa, G., and Guiliani, D. (2018). Measuring the spatial balance of a sample: A new measure based on Moran's I index.
#' \emph{Spatial Statistics}, 23, 182-192. \url{https://doi.org/10.1016/j.spasta.2018.02.001}
#' 
#' @seealso
#' \code{\link{wpik2}}, \code{\link{distUnitk}}, \code{\link{wave}}.
#' 
#' @export
wpik <- function(X, pik, bound = 1.0, tore = FALSE, jitter = FALSE, toreBound = -1.0) {
    .Call(`_wave_wpik`, X, pik, bound, tore, jitter, toreBound)
}

#' @title Weights calculated from pik
#'
#' @description
#'
#' The weights are calculated in a way that a unit represents its neighbor till their inclusion probabilities sum to 1.
#' Hence each line represent a strata centered around the unit i and that sum up to 1.
#'
#' @param X A matrix of size N x 2, it should represent the 2D position of the units.
#' @param pik vector of inclusion probabilites.
#' @param bound bound to reached before a new strata is considered. Default is 1.
#' @param tore logical, if we are considering the distance on a tore. Default is TRUE.
#' @param jitter logical, if you would use a jitter perturbation. See Details for more infomrations. Default is FALSE.
#' @param toreBound A numeric value that specify the size of the grid.
#'
#' @return A sparse matrix.
#' @export
wpik2 <- function(X, pik, tore, jitter, toreBound) {
    .Call(`_wave_wpik2`, X, pik, tore, jitter, toreBound)
}

