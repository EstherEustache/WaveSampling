# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @encoding UTF-8
#' @title Spatial balance based on Moran's I index
#'
#' @description
#'
#' This function implements the spatial balanced based on Moran's I index.
#'
#' @param W A \code{\link[Matrix]{sparseMatrix}} representing the spatial weights. See \code{\link{wpik}}.
#' @param s A numeric vector of 0 and 1 that represent the sample.
#'
#' @return A numeric value that represent the spatial spreading measure. It could be any real value between -1 (spread) and 1 (clustered). 
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references
#' Tillé, Y., Dickson, M.M., Espa, G., and Guiliani, D. (2018). Measuring the spatial balance of a sample: A new measure based on Moran's I index.
#' \emph{Spatial Statistics}, 23, 182-192. \url{https://doi.org/10.1016/j.spasta.2018.02.001}
#' 
#' @seealso
#' \code{\link{wpik}}
#' 
#' @examples
#' \dontrun{
#'   N <- 100
#'   n <- 20
#'   x <- seq(1,sqrt(N),1)
#'   X <- expand.grid(x,x)
#'   pik <- rep(n/N,N)
#'   W <- wpik(as.matrix(X),pik,bound = 1,tore = TRUE,jitter = FALSE,toreBound = sqrt(N))
#'   W <- W - diag(diag(W))
#'   s <- round(wave(as.matrix(X),pik,tore = TRUE,jitter = TRUE,comment = TRUE))
#'   system.time(I1 <- IB(W,s))
#' 
#'   plot(X)
#'   points(X[s == 1,],pch = 16)
#' }
#' 
#' @export
IB <- function(W, s) {
    .Call(`_wave_IB`, W, s)
}

#' @encoding UTF-8
#' @title Iterative proportional fitting procedure (IPFP) or raking ratio.
#' 
#' @description
#' Iterative proportional fitting procedure (IPFP) implemented for \code{\link[Matrix]{sparseMatrix}}.
#'
#' @param A A \code{\link[Matrix]{sparseMatrix}}.
#' @param bh A vector representing the row margin.
#' @param bi A vector representing the columm margin.
#' @param maxiter An integer indicating the maximum iterations allowed.
#' @param tol A real value that the error should reach before stoped.
#' @param comment an optional logical value, indicating some informations during the execution. Default is FALSE.
#' 
#' @return the sparse matrix A adjusted.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references
#' Tillé, Y. (2019). \emph{Théorie des sondages}. Dunod, 2nd édition
#' 
#' @seealso
#'  \code{\link{IPFPsym}}, \code{\link{wpik}}
#' 
#' @examples
#' \dontrun{
#' X <- as.matrix(cbind(runif(1000),runif(1000)))
#'   pik <- rep(1/5,1000)
#'   A <- wpik(X,pik,bound = 1,tore = FALSE,jitter = FALSE,toreBound = 0.0)
#'   A <- A+t(A)
#'   isSymmetric(A)
#'   
#'   A1 <- IPFP(A,bh = rep(1,nrow(A)),
#'             bi = rep(1,nrow(A)),
#'             maxiter = 1000,
#'             tol = 1e-4,
#'             comment = TRUE)
#'   A2 <- IPFPsym(A,bh = rep(1,nrow(A)),
#'             bi = rep(1,nrow(A)),
#'             maxiter = 4000,
#'             tol = 1e-4,
#'             comment = TRUE) # takes more iterations because the symmetric structure is kept.
#'   rowSums(A1)
#'   rowSums(A2)
#'   colSums(A1)
#'   colSums(A2)
#'   
#'   isSymmetric(A1) # not symmetric
#'   isSymmetric(A2) # symmetric
#' }
#' 
#' @export
IPFP <- function(A, bh, bi, maxiter = 300L, tol = 1e-9, comment = FALSE) {
    .Call(`_wave_IPFP`, A, bh, bi, maxiter, tol, comment)
}

#' @encoding UTF-8
#' @title Iterative proportional fitting procedure (IPFP) or raking ratio for symmetric sparse matrix.
#' 
#' @description
#' Iterative proportional fitting procedure (IPFP) implemented for \code{\link[Matrix]{sparseMatrix}}.
#'
#' @param A A \code{\link[Matrix]{sparseMatrix}}.
#' @param bh A vector representing the row margin.
#' @param bi A vector representing the columm margin.
#' @param maxiter An integer indicating the maximum iterations allowed.
#' @param tol A real value that the error should reach before stoped.
#' @param comment an optional logical value, indicating some informations during the execution. Default is FALSE.
#' 
#' @return the sparse matrix A adjusted.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references
#' Tillé, Y. (2019). \emph{Théorie des sondages}. Dunod, 2nd édition
#' 
#' @seealso
#' \code{\link{IPFP}}, \code{\link{wpik}}
#' 
#' @examples
#' \dontrun{
#'   X <- as.matrix(cbind(runif(1000),runif(1000)))
#'   pik <- rep(1/5,1000)
#'   A <- wpik(X,pik,bound = 1,tore = FALSE,jitter = FALSE,toreBound = 0.0)
#'   A <- A+t(A)
#'   isSymmetric(A)
#'   
#'   A1 <- IPFP(A,bh = rep(1,nrow(A)),
#'             bi = rep(1,nrow(A)),
#'             maxiter = 1000,
#'             tol = 1e-4,
#'             comment = TRUE)
#'   A2 <- IPFPsym(A,bh = rep(1,nrow(A)),
#'             bi = rep(1,nrow(A)),
#'             maxiter = 4000,
#'             tol = 1e-4,
#'             comment = TRUE) # takes more iterations because the symmetric structure is kept.
#'   rowSums(A1)
#'   rowSums(A2)
#'   colSums(A1)
#'   colSums(A2)
#'   
#'   isSymmetric(A1) # not symmetric
#'   isSymmetric(A2) # symmetric
#' }
#' 
#' @export
IPFPsym <- function(A, bh, bi, maxiter = 300L, tol = 1e-9, comment = FALSE) {
    .Call(`_wave_IPFPsym`, A, bh, bi, maxiter, tol, comment)
}

#' @title Square of the euclidean distance of the unit k.
#'
#' @description
#' Calculate the squared distance from the unit k to all other units.
#' 
#'
#' @param X matrix of size N x 2 representing the spatial coordinates. 
#' @param k the unit index to be used.
#' @param tore an optional logical value, if we are considering the distance on a tore. Default is TRUE.
#' @param toreBound an optional numeric value that specify the size of the grid.
#'
#'
#' @details
#' 
#' Let \eqn{x_k} be the spatial coordinates. The classical euclidean distance is given by
#' 
#' \deqn{d^2(k,l) = (x_k - x_l)^\top (x_k - x_l). }
#' 
#' When the points are distributed on a \eqn{r_1 \times r_2} regular grid of \eqn{R^2}.
#' It is possible to consider the units like they were placed on a tore. Specifically,
#' we could consider two units on the same column (resp. row) that are on the opposite have a small distance.
#' 
#' \deqn{ d(k,l) = min( (x_{k_1} - x_{l_1})^2,
#'                       (r_1 + x_{k_1} - x_{l_1})^2,
#'                       (r_1 - x_{k_1} + x_{l_1}))^2}
#' \deqn{+}
#' \deqn{ min( (x_{k_2} - x_{l_2})^2,
#'                       (r_2 + x_{k_2} - x_{l_2})^2,
#'                       (r_2 - x_{k_2} + x_{l_2}))^2}
#'
#' @return the distance values of the unit k.
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' 
#' @seealso
#' \code{\link{wpik}}, \code{\link{wave}}.
#'
#' @export
distUnitk <- function(X, k, tore, toreBound) {
    .Call(`_wave_distUnitk`, X, k, tore, toreBound)
}

#' @encoding UTF-8
#' @title Projection operator
#'
#' @description
#'
#' This operator projects the vector v orthogonally onto the line spanned by vector u.
#'
#' @param v vector projected.
#' @param u vector that define the line on which we project.
#' 
#' @details
#' 
#' The projection operator is defined by :
#' 
#' \deqn{proj_u(v) = \frac{\langle u , v \rangle}{\langle u, u \rangle} u}
#'  where \eqn{\langle . , . \rangle} is the inner product also written \eqn{u^\top v}.
#' 
#' @return The projection of the vector v onto the line spanned by the vector u.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references 
#' \url{https://en.wikipedia.org/wiki/Projection_(linear_algebra)}s
#' 
#' 
#' @examples
#' \dontrun{
#' u = c(0,1)
#' v = c(1,1)
#' projOp(v,u)
#' v - projOp(v,u)
#' }
#' 
#' @export
projOp <- function(v, u) {
    .Call(`_wave_projOp`, v, u)
}

#' @title Column sums on sparse matrix.
#'
#' @description
#' Same usage of the function \code{\link[Matrix]{colSums}}.
#'
#' @param x A sparse matrix of class \code{\link[Matrix]{sparseMatrix}}.
#'
#' @details
#' This function is designed to be used for other \code{RcppArmadillo} function inside of the package. Nevertheless it could be used in R.
#' It only loops on the non-zero entries of the sparseMatrix. The function \code{\link[Matrix]{colSums}} should be prefer because is 
#' a little bit faster.
#'
#' @return A numeric vector that represent the sums of the column of x. 
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @seealso
#' \code{\link[Matrix]{colSums}}, \code{\link[Matrix]{rowSums}}.
#' 
#' @examples
#' \dontrun{
#' sp <- rsparsematrix(5000,5000,density = 0.4)
#' system.time(test1 <- Matrix::colSums(sp))
#' system.time(test2 <- colSumsiter(sp))
#' }
#' @export
colSumsiter <- function(x) {
    .Call(`_wave_colSumsiter`, x)
}

#' @title Row sums on sparse matrix.
#'
#' @description
#' Same usage of the function \code{\link[Matrix]{rowSums}}.
#'
#' @param x A sparse matrix of class \code{\link[Matrix]{sparseMatrix}}.
#'
#' @details
#' This function is designed to be used for other \code{RcppArmadillo} function inside of the package. Nevertheless it could be used in R.
#' It only loops on the non-zero entries of the sparseMatrix. The function \code{\link[Matrix]{rowSums}} should be prefer because is 
#' a little bit faster.
#'
#' @return A numeric vector that represent the sums of the rows of x. 
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @seealso
#' \code{\link[Matrix]{colSums}}, \code{\link[Matrix]{rowSums}}.
#' 
#' 
#' @examples
#' \dontrun{
#' sp <- rsparsematrix(5000,5000,density = 0.4)
#' system.time(test1 <- Matrix::colSums(sp))
#' system.time(test2 <- colSumsiter(sp))
#' }
#' 
#' @export
rowSumsiter <- function(x) {
    .Call(`_wave_rowSumsiter`, x)
}

#' @encoding UTF-8
#' @title Weakly associated vectors sampling
#'
#' @description
#'
#' Select spread spatial samples with inclusion probabilities using the weakly associated vectors sampling method.  
#'
#' @param X matrix of size N x 2 representing the spatial position. 
#' @param pik vector of the inclusion probabilites. The length should be equal to N.
#' @param bound A scalar representing the bound to reach before a new strata is considered. See \code{\link{wpik}}. Default is 1.
#' @param tore an optional logical value, if we are considering the distance on a tore. See \code{\link{distUnitk}}. Default is TRUE.
#' @param jitter an optional logical value, if you would use a jitter perturbation. See Details for more infomrations. Default is FALSE.
#' @param oneD an optional logical value, specifying if we are in one dimension. Default is FALSE.
#' @param comment an optional logical value, indicating some informations during the execution. Default is FALSE.
#'
#' @details
#' 
#' A contiguity table \eqn{W} is calculated from the matrix \eqn{X}.
#' \code{wave} sampling estimate a vector \eqn{u} that is
#' the weakest associated vector of the linear transformations generated by \eqn{W}.
#' The vector \eqn{u} is then used to update the inclusion probabilities vector \eqn{\pi_k}.
#' 
#'
#' @return A vector of size N with elements equal 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for non-selected unit.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references 
#' \url{https://en.wikipedia.org/wiki/Singular_value_decomposition}
#' 
#' @seealso
#' \code{\link{wpik}}, \code{\link{distUnitk}}.
#' 
#' 
#' @examples
#' \dontrun{
#'   N <- 36 # 6 x 6 grid
#'   n <- 12 # number of unit selected
#'   x <- seq(1,sqrt(N),1)
#'   X <- as.matrix(cbind(rep(x,times = sqrt(N)),rep(x,each = sqrt(N))))
#'   pik <- rep(n/N,N)
#'   s <- wave(X,pik, tore = TRUE,jitter = FALSE)
#'   plot(X)
#'   points(X[s == 1,],pch = 16)
#' }
#' 
#' 
#' 
#' @export
wave <- function(X, pik, bound = 1.0, tore = FALSE, jitter = FALSE, oneD = FALSE, comment = FALSE) {
    .Call(`_wave_wave`, X, pik, bound, tore, jitter, oneD, comment)
}

#' @encoding UTF-8
#' @title Spatial weights from pik
#'
#' @description
#'
#' Spatial weights calculated from inclusion probabilies taking distance between units into account.
#'  
#'
#' @param X matrix of size N x 2 representing the spatial coordinates. 
#' @param pik vector of the inclusion probabilites. The length should be equal to N.
#' @param bound A scalar representing the bound to reach before a new strata is considered. See \code{\link{wpik}}. Default is 1.
#' @param tore an optional logical value, if we are considering the distance on a tore. See \code{\link{distUnitk}}. Default is TRUE.
#' @param jitter an optional logical value, if you would use a jitter perturbation. See Details for more infomrations. Default is FALSE.
#' @param toreBound A numeric value that specify the size of the grid.
#' 
#' @details
#' 
#' Spatial weights indicates how close the units are frome each others. Hence a large value \eqn{w_{ij}} means that the unit i 
#' is close to the unit j. This function consider that a unit represents its neighbor till their inclusion probabilities
#' sum to 1.
#' 
#' We define \eqn{H_i} the set of the nearest neighbor of the unit i including i such that the sum of their inclusion
#' probabilities is just greater than 1. Moreover, let \eqn{h_i = card{H_i}}, the number of elements in \eqn{H_i}.
#' The matrix \eqn{W} is then defined as follows,
#' 
#' \deqn{ w_{ij} = \pi_j}
#'  if unit j is in the set of the  \eqn{h_i - 1} nearest neighbor of \eqn{i}.
#' \deqn{ w_{ij} = g_j}
#'  if unit j is the \eqn{h_i} nearest neighbour of \eqn{i}.
#' \deqn{w_{ij} = 0}
#'  otherwise.
#' 
#' where \eqn{g_j = 1- (\sum_{k \in H_i} \pi_k -\pi_j)}. Hence, the ith row of the matrix represents
#' neighborhood or stratum of the unit such that the inclusion probabilities sum up to 1 and
#' the ith column the weights that unit i takes for each stratum. 
#' 
#' 
#' @return A sparse matrix representing the spatial weights.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references 
#' Tillé, Y., Dickson, M.M., Espa, G., and Guiliani, D. (2018). Measuring the spatial balance of a sample: A new measure based on Moran's I index.
#' \emph{Spatial Statistics}, 23, 182-192. \url{https://doi.org/10.1016/j.spasta.2018.02.001}
#' 
#' @seealso
#' \code{\link{wpik2}}, \code{\link{distUnitk}}, \code{\link{wave}}.
#' 
#' @export
wpik <- function(X, pik, bound = 1.0, tore = FALSE, jitter = FALSE, toreBound = -1.0) {
    .Call(`_wave_wpik`, X, pik, bound, tore, jitter, toreBound)
}

#' @encoding UTF-8
#' @title Spatial weights from pik
#'
#' @description
#'
#' Spatial weights calculated from inclusion probabilies taking distance between units into account. It is a direct
#' implementation of the spatial weights specified in [Tillé et al., 2018].
#'
#' @param X matrix of size N x 2 representing the spatial coordinates. 
#' @param pik vector of the inclusion probabilites. The length should be equal to N.
#' @param tore an optional logical value, if we are considering the distance on a tore. See \code{\link{distUnitk}}. Default is TRUE.
#' @param jitter an optional logical value, if you would use a jitter perturbation. See Details for more infomrations. Default is FALSE.
#' @param toreBound A numeric value that specify the size of the grid.
#' 
#' @details
#' 
#' Spatial weights indicates how close the units are frome each others. Hence a large value \eqn{w_{ij}} means that the unit \eqn{i} 
#' is close to the unit \eqn{j}. This function consider that if \eqn{i} were selected in the sample drawn from the population then
#' \eqn{i} would represent \eqn{1/\pi_i} units in the population and, as a consequence, it would onl be natural to consider
#' that \eqn{i} has \eqn{k_i = (1/\pi_i -1 )} neighbours in the population. The \eqn{k_i} neighbours can be the nearest 
#' neighbours of \eqn{i} according to the distance. The weights are so calculated as follows,
#' 
#' \deqn{ w_{ij} = 1}
#'  if unit \eqn{j \in N_{\lfloor k_i \rfloor}}.
#' \deqn{ w_{ij} = k_i - \lfloor k_i \rfloor}
#'  if unit j is the \eqn{\lceil k_i \rceil} the nearest neighbour of i.
#' \deqn{w_{ij} = 0}
#'  otherwise.
#' 
#' where \eqn{ \lfloor k_i \rfloor} and \eqn{\lceil k_i \rceil} bet he inferior and the superior integers of \eqn{k_i}.
#' 
#' @return A sparse matrix representing the spatial weights.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @references 
#' Tillé, Y., Dickson, M.M., Espa, G., and Guiliani, D. (2018). Measuring the spatial balance of a sample: A new measure based on Moran's I index.
#' \emph{Spatial Statistics}, 23, 182-192. \url{https://doi.org/10.1016/j.spasta.2018.02.001}
#' 
#' @seealso
#' \code{\link{wpik2}}, \code{\link{distUnitk}}, \code{\link{wave}}.
#' 
#' @export
wpik2 <- function(X, pik, tore, jitter, toreBound) {
    .Call(`_wave_wpik2`, X, pik, tore, jitter, toreBound)
}

